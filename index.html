<!DOCTYPE html>
<html><head>
	<meta name="generator" content="Hugo 0.78.2" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>Portfolio</title>
    <meta name="description" content="">
    <meta name="author" content=''>

    <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">

    
    <link rel="stylesheet" href="/sass/researcher.min.css">

    

    <link rel="alternate" type="application/rss+xml" href="https://limzportfolio.github.io/index.xml" title="Portfolio" />
    
        
    
</head>

    <body><div class="container mt-5">
    <nav class="navbar navbar-expand-sm flex-column flex-sm-row text-nowrap p-0">
        <a class="navbar-brand mx-0 mr-sm-auto" href="https://limzportfolio.github.io/">Portfolio</a>
        <div class="navbar-nav flex-row flex-wrap justify-content-center">
            
        </div>
    </nav>
</div>
<hr>
<div id="content">
<div class="container">
    <h1 id="unity-automatic-light-probe-generator">Unity automatic light probe generator</h1>
<h5 id="february-2021---current">[February 2021 - Current]</h5>
<br/><br/>
<p><strong>Precomputed Lighting in CoD IW 2017</strong> 발표 자료의 <strong>Light Grid</strong> 항목에 근거하여 작성한 <em>Light porbe generator</em>입니다.<br>
<em>Probe searching</em>의 경우, 상기 발표 자료와 더불어 <strong>Robert Cupisz</strong>가 기술한 <strong>Light probe interpolation using tetrahedral tessellations</strong>를 토대로 작성하였습니다.</p>
<br/><br/>
<h3 id="preview">Preview:</h3>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/9jlmRDcV6eA" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<br/><br/>
<h3 id="what-jobs-i-did">What jobs I did:</h3>
<p>개선이 필요한 부분:</p>
<p>현재 까지의 진행 상황에선 Subdivided geometry의 Volume 최소 크기 및 각 Vertex의 SH 색상 변화 정도를 Threshold와 비교하여 얼마동안 Subdivide를 진행 할 지 여부를 결정하도록 하였습니다.<br>
다만 이 경우, Neighbor geometry와의 비교 부재로 인해 Subdivide될 수록 다량의 Geometry가 생성됨을 확인할 수 있었습니다. 따라서 Subdivide 진행 중, 동일 Level 상의 Subdivided geometry간의 비교 혹은 Subdivide 완료 이후 각 Geometry간의 비교를 통해 Reduction을 진행 할 예정입니다.</p>
<p>Tetrahedron의 각 4개의 Vertex는 각각이 마주하는 Face에 대해 일정한 간격으로 Vertex로부터 Face까지의 Depth값을 가지고 있습니다. 따라서 어떤 Random position이 Tetrahedron 내부에 존재한다고 가정할 때 각 Vertex의 Random position에 대한 Occlusion 여부를 Cached depth를 통하여 빠르게 판단할 수 있습니다. 예컨대, 닫혀있는 공간과 그 바깥의 경계에 Tetrahedron이 걸쳐있다고 생각해 봅시다. 이 때 3개의 Vertex는 닫혀있는 공간에 존재하고 나머지 1개의 Vertex는 그 바깥에 있습니다. 여기서 Random position이 닫혀있는 공간쪽의 Tetrahedron 내부에 위치한다고 가정해보면, 바깥 Vertex로부터 Random position까지의 Depth가 Cached depth보다 크기 때문에 Random position입장에서 바깥의 Vertex는 Occlude 되었다고 판단할 수 있으며, 따라서  내부 3개의 Vertex에 해당하는 SH 색상만 보간하여 사용할 수 있습니다.<br>
다만 Geometry의 복잡도에 따라 모든 4개 Vertex의 Cached depth로 부터 Occlude 되었다고 판단할 수 있는 경우가 존재합니다. 이런 현상을 어느정도 방지하기 위하여 마련한 대책은 다음과 같습니다.</p>
<ul>
<li>Tetrahedron의 각 Vertex마다 마주하는 Face에 일정 간격으로 15개의 Ray를 발사합니다. 이 때 Occluder의 위치를 0.0(Vertex와 아주 가깝거나 겹쳐있음)에서 1.0(마주하는 Face보다 뒤에 있거나 Occlude되지 않음)사이의 값으로 묘사합니다.</li>
<li>최소 2개 이상의 Vertex가 완전히 Occlude되어있는지(15개의 Ray로 부터 1.0값이 하나도 검출이 되지 않았는지) 판별합니다. 2개 이상의 Vertex가 완전히 Occlude되었다면 이하의 방법으로 Subdivision을 진행합니다.</li>
</ul>
<ol>
<li>완전히 Occlude된 Vertex가 2개인 경우, 두 Vertex 사이의 중점 P를 기준으로 Subdivision을 진행하여 두개의 Tetrahedron을 생성합니다.</li>
<li>완전히 Occlude된 Vertex가 2개 초과인 경우, <strong>S. Schaefer</strong>가 기술한 <strong>Smooth Subdivision of Tetrahedral Meshes</strong>의 <strong>A tetrahedral subdivision scheme</strong> 항목을 고려하여 Tetrahedron 및 Octahedron으로 Subdivision을 진행합니다.</li>
<li>상기의 두 방법을 반복하며 생성된 Geometry의 Volume 크기를 계산하고 일정 수준 이하 작아지게 되면 반복을 중단합니다.</li>
</ol>
<br/><br/>
<h3 id="used-languageslibraries">Used languages/libraries:</h3>
<p>C++(Visual C++), C#(Unity), HLSL(Unity; ComputeShader), Intel TBB</p>
<p><br/><br/>
<br/><br/></p>
<h1 id="smooth-trail">Smooth trail</h1>
<br/><br/>
<p>Developed smooth trail line using Cardinal Spline and SQUAD Quadratic interpolation.</p>
<br/><br/>
<h3 id="preview-1">Preview:</h3>
<p>In game usage: 

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/tag" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<br/><br/>
Quadratic interpolation comparison between SQUAD and Estimated SQUAD: 

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/tag" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>
</p>
<br/><br/>
<h3 id="what-jobs-i-did-1">What jobs I did:</h3>
<p>Unlike basic trail line, I interpolated every two points of frame by frame to make it looks smooth.</p>
<p>Since SQUAD interpolation is pretty expensive to compute, I estimated it using linear interpolation with normalization. Then I could improve the calculation speed up to N%.</p>
<p>Also, both SQUAD and estimated SQUAD are not so different visually.</p>
<br/><br/>
<h3 id="used-languageslibraries-1">Used languages/libraries:</h3>
<p>DirectX 9.0c, Visual C++</p>
<p><br/><br/>
<br/><br/></p>
<h1 id="ghost-war-character-shaderunity-mobile-project">Ghost war character shader(Unity mobile project)</h1>
<br/><br/>
<p>Unity based mobile game <a href="https://play.google.com/store/apps/details?id=com.rhaon.ghostwar&amp;hl=en&amp;gl=US">Ghost War</a> character shader.</p>
<br/><br/>
<h3 id="preview-2">Preview:</h3>
<p>Common objects: 

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/hbm7MRPEA5o" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<br/><br/>
Hologram mode: 

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/uGGg8W3yeoM" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<br/><br/>
Gameplay sample: 

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/I9DEkEjP5hw" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>
</p>
<br/><br/>
<h3 id="what-jobs-i-did-2">What jobs I did:</h3>
<p>Toon shading and directional rim lighting are applied for basic looking. And I used dithering effect for object fading.</p>
<p>Also I implemented Spherical Environment Mapping to express metalic surface.</p>
<p>In order to avoid face splitting of an outline mesh, I calculated average normal direction for vertices which placed on a same position.</p>
<br/><br/>
<h3 id="used-languageslibraries-2">Used languages/libraries:</h3>
<p>C#(Unity), HLSL(Unity)</p>

</div>

        </div><div id="footer" class="mb-5">
    
</div>
</body>
</html>
